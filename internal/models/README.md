# Adding Attributes to Models

This guide explains how to add new attributes to existing models in the `internal/models/project` directory.


## Overview

Each model typically consists of four key components that must be kept in sync:

1. **Attributes Map** - Terraform schema definition
2. **Model Struct** - Go struct with typed fields
3. **Serialization Methods** - `Values()` and `SetValues()` for JSON conversion
4. **Documentation** - Each attribute needs a short documentation line


## Required Steps


### 1. Add to Attributes Map

Pick a name for the new attribute. This is what users will type when editing their `.tf` files. Attribute names are
always in snake case. Try to pick an idiomatic Terraform name, looking at existing models for inspiration.

Add the attribute to the `*Attributes` map variable with the appropriate schema type and options. Attributes are
defined declaratively by calling special functions from the `*attr` packages, for example:

```go
var ExampleAttributes = map[string]schema.Attribute{
    "existing_field": stringattr.Required(),
    "new_field":      boolattr.Default(false),  // ← new line
}
```

**Common type packages:**

- `stringattr` - String values
- `boolattr` - Boolean values
- `intattr` - Integer values
- `durationattr` - Duration strings
- `strsetattr` - Set of strings
- `listattr` - List of nested objects/models
- `objattr` - Single nested object/model

**Common type functions:**

- `.Required()` - Must be specified by the user in the plan
- `.Default(value, ...)` - Gets a default or empty value unless specified in the plan
- `.Optional()` - Gets an unknown value unless specified in the plan
- Add validators as additional parameters (e.g., `stringvalidator.LengthAtMost(100)`)
- Validators can work on both containers and their items

**Special cases:**

- `stringattr.Identifier()` - A special string attribute used for IDs that are autogenerated by the backend
- `stringattr.IdentifierMatched()` - Like `Identifier` but with special logic to preserve IDs in containers
- Add modifiers in special cases to modify `Unknown` values not specified in the `.tf` plan


### 2. Add to Model Struct

Add a corresponding field to the model `struct` with the appropriate type and `tfsdk` tag with the same key
as the attribute name in the `*Attributes` map.

For clarity, the type of the `struct` field is always the `Type` alias from the package used above. So for example,
if you add a new string attribute you might define it in the map as `stringattr.Default("")`, in which case the type
in the model struct will be `stringattr.Type`.

```go
type ExampleModel struct {
    ExistingField stringattr.Type `tfsdk:"existing_field"`
    NewField      boolattr.Type   `tfsdk:"new_field"`  // ← new line
}
```


### 3. Add to Values() Method

Serialize the field to JSON in the `Values()` method using the appropriate `Get` function.

This function is called when we want to create a snapshot representation for the model to send to the Descope
backend. The JSON key passed to the `Get` function as the third parameter should match the one used in our
project snapshots.

Again, you should use the `Get` function from the `*attr` package matching the type of the attribute, for example:

```go
func (m *ExampleModel) Values(h *helpers.Handler) map[string]any {
    data := map[string]any{}
    stringattr.Get(m.ExistingField, data, "existingField")
    boolattr.Get(m.NewField, data, "newField")  // ← new line
    return data
}
```

**Notes:**
- Some `Get` calls for container types require the `h` parameter as the last one
- For objects: `objattr.Get(m.NestedField, data, "nestedKey", h)`
- For object lists: `listattr.Get(m.ListField, data, "listKey", h)`
- For string sets: `strsetattr.Get(m.SetField, data, "setKey", h)`


### 4. Add to SetValues() Method

Deserialize the field from JSON in the `SetValues()` method using the appropriate `Set` function.

This function is called when we read the project state from the backend or we get a response after an update, and
we want to update the model struct with the data from the snapshot representation.

> [!TIP]
> You can almost always copy the lines from the `Values` function, change `Get` to `Set`, and add an `&` before
> the first parameters.

```go
func (m *ExampleModel) SetValues(h *helpers.Handler, data map[string]any) {
    stringattr.Set(&m.ExistingField, data, "existingField")
    boolattr.Set(&m.NewField, data, "newField")  // ← new line
}
```

> [!IMPORTANT]
> The `terraform` tool expects that model struct to have the same values before and after the plan is applied,
> unless the value in the plan was `Unknown`. In other words, if the user picks a value of `true` for `newField`
> and the `SetValues` function changes `m.NewField` to have a value of `false` because that's what the backend
> returned, that is considered an error and the `terraform` tool will complain.


### 5. Documentation

Run `make terragen` once to create a documentation placeholder for your new attribute in the appropriate `.md` file
under `docs/raw`. Replace the `//` placeholder line with a succinct explanation of the new attribute. Finally, run
the `make terragen` command again and then run `make docs`.

> [!NOTE]
> The `make terragen` command might complain about missing value for the `DESCOPE_TEMPLATES_PATH` environment variable.
> Run `export DESCOPE_TEMPLATES_PATH=...` with the path to the `connectors/templates` directory in the `content` repo to
> resolve this.

## Optional Steps

### Add Validators

If a model object needs validation logic, implement or update the `Validate()` method:

```go
func (m *ExampleModel) Validate(h *helpers.Handler) {
	if helpers.HasUnknownValues(m.ExistingField, m.NewField) {
		return // skip validation if there are unknown values
	}

    if m.ExistingField.ValueString() == "" && m.NewField.ValueBool() {
        h.Invalid("new_field requires existing_field to be set")
    }
}
```

> [!CAUTION]
> The `Validate` function is called multiple times in different stages. In particular, it is called before any dynamic
> values are evaluated. As such, your `Validate` implementation should ignore any attributes in an `Unknown` state.

Create a validator object above the `*Attributes` map in the same file:

```go
var ExampleValidator = objattr.NewValidator[ExampleModel]("short description of what it does")

var ExampleAttributes = map[string]schema.Attribute{
    // attributes...
}
```

And reference it in the parent model:

```go
"example": objattr.Required[ExampleModel](ExampleAttributes, ExampleValidator),
```

### Add Modifiers

For dynamic field modifications, usually to handle autogenerated IDs in containers, implement or
update the `Modify()` method:

```go
func (m *ExampleModel) Modify(h *helpers.Handler, state *ExampleModel) {
    // m is the plan object with the values set by the user and it might contain Unknown and Null values
    // state is the current value from the state and it might contain Null values
}
```

Ensure the model includes a modifier:

```go
var ExampleModifier = objattr.NewModifier[ExampleModel]("short description of what it does")
```

And reference it in the parent model:

```go
"example": objattr.Default[ExampleModel](nil, ExampleAttributes, ExampleModifier),
```

### Add Reference Management

For attributes that reference other resources (e.g., connector IDs), implement these methods:

> [!NOTE]
> References always require additional logic in the backend to generate the unique IDs.

**Collect references** during plan phase:

```go
func (m *ExampleModel) CollectReferences(h *helpers.Handler) {
    h.Refs.Add(helpers.SomeReferenceKey, "", m.ID.ValueString(), m.Name.ValueString())
}
```

**Update references** when applying:

```go
func (m *ExampleModel) UpdateReferences(h *helpers.Handler) {
    objattr.UpdateReferences(&m.NestedField, h)
}
```


## Special Cases

### Key-Value Mapping Differences

Some attributes use different keys between Terraform (tfsdk) and JSON (API):

```go
// Terraform uses "refresh_token_expiration"
// But JSON API uses "refreshTokenExpiration"
durationattr.Get(m.RefreshTokenExpiration, data, "refreshTokenExpiration")
```

### Conditional Serialization

Use the `GetNot` or custom logic for inverted values:

```go
// "disabled" in Terraform maps to "enabled" (inverted) in JSON
boolattr.GetNot(m.Disabled, data, "enabled")
```

### Nested Lists with Matching

For lists that need to preserve order across updates:

```go
// In SetValues, use SetMatchingNames to match by a key field
listattr.SetMatchingNames(&m.Items, data, "items", "name", h)
```

## Common Pitfalls

You can check existing models to see if you're missing anything, but common mistakes are:

- Forgetting to add the field to all three places (Attributes, Struct, Values/SetValues)
- Mismatched `tfsdk` tag and Attributes map key
- Wrong JSON key name in Values/SetValues (export a snapshot from the console to doublecheck)

## Testing

After adding attributes:

1. Add acceptance test for your new attribute, usually as a new step in an existing test
2. Run all acceptance tests with `make testacc`
3. Run specific acceptance tests by supplying the test name, e.g., `make testacc tests=Authorization`
4. Verify the attribute appears correctly in Terraform plans and applies

## Examples

See existing models for reference:

- **Simple attributes**: `authorization/permission.go`
- **Complex nested models**: `authentication/password.go`
- **Lists with matching**: `attributes/attributes.go`
- **Validators and modifiers**: `authorization/role.go`
- **Reference management**: `connectors/connectors.go`
