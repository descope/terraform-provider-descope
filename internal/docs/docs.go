// Code generated by terragen. DO NOT EDIT.

package docs

var docsProject = map[string]string{
	"name": "The name of the Descope project.",
	"environment": "This can be set to `production` to mark production projects, otherwise this should be " +
	               "left unset for development or staging projects.",
	"tags": "Descriptive tags for your Descope project. Each tag must be no more than 50 characters long.",
	"project_settings": "General settings for the Descope project.",
	"invite_settings": "User invitation settings and behavior.",
	"authentication": "Settings for each authentication method.",
	"authorization": "Define Role-Based Access Control (RBAC) for your users by creating roles and permissions.",
	"attributes": "Custom attributes that can be attached to users and tenants.",
	"connectors": "Enrich your flows by interacting with third party services.",
	"applications": "Applications that are registered with the project.",
	"jwt_templates": "Defines templates for JSON Web Tokens (JWT) used for authentication.",
	"styles": "Custom styles that can be applied to the project's authentication flows.",
	"flows": "Custom authentication flows to use in this project.",
}

var docsApplications = map[string]string{
	"oidc_applications": "Applications using OpenID Connect (OIDC) for authentication.",
	"saml_applications": "Applications using SAML for authentication.",
}

var docsOIDC = map[string]string{
	"id": "An optional identifier for the OIDC application.",
	"name": "A name for the OIDC application.",
	"description": "A description for the OIDC application.",
	"logo": "A logo for the OIDC application. Should be a hosted image URL.",
	"disabled": "Whether the application should be enabled or disabled.",
	"login_page_url": "The Flow Hosting URL. Read more about using this parameter with custom " +
	                  "domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).",
	"claims": "A list of supported claims. e.g. `sub`, `email`, `exp`.",
	"force_authentication": "This configuration overrides the default behavior of the SSO application and forces " +
	                        "the user to authenticate via the Descope flow, regardless of the SP's request.",
}

var docsSAML = map[string]string{
	"id": "An optional identifier for the SAML application.",
	"name": "A name for the SAML application.",
	"description": "A description for the SAML application.",
	"logo": "A logo for the SAML application. Should be a hosted image URL.",
	"disabled": "Whether the application should be enabled or disabled.",
	"login_page_url": "The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).",
	"dynamic_configuration": "The `DynamicConfiguration` object. Read the description below.",
	"manual_configuration": "The `ManualConfiguration` object. Read the description below.",
	"acs_allowed_callback_urls": "A list of allowed ACS callback URLS. This configuration is used when the default ACS URL value is unreachable. Supports wildcards.",
	"subject_name_id_type": "The subject name id type. Choose one of \"\", \"email\", \"phone\". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).",
	"subject_name_id_format": "The subject name id format. Choose one of \"\", \"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\", \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\", \"urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\", \"urn:oasis:names:tc:SAML:2.0:nameid-format:transient\". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).",
	"default_relay_state": "The default relay state. When using IdP-initiated authentication, this value may be used as a URL to a resource in the Service Provider.",
	"attribute_mapping": "The `AttributeMapping` object. Read the description below.",
	"force_authentication": "This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.",
}

var docsAttributeMapping = map[string]string{
	"name": "The name of the attribute.",
	"value": "The value of the attribute.",
}

var docsDynamicConfiguration = map[string]string{
	"metadata_url": "The metadata URL when retrieving the connection details dynamically.",
}

var docsManualConfiguration = map[string]string{
	"acs_url": "Enter the `ACS URL` from the SP.",
	"entity_id": "Enter the `Entity Id` from the SP.",
	"certificate": "Enter the `Certificate` from the SP.",
}

var docsAttributes = map[string]string{
	"tenant": "A list of `TenantAttribute`. Read the description below.",
	"user": "A list of `UserAttribute`. Read the description below.",
}

var docsTenantAttribute = map[string]string{
	"name": "The name of the attribute.",
	"type": "The type of the attribute. Choose one of \"string\", \"number\", \"boolean\", \"singleselect\", \"multiselect\", \"date\".",
	"select_options": "When the attribute type is \"multiselect\". A list of options to chose from.",
	"authorization": "Determines the required permissions for this tenant.",
}

var docsTenantAttributeAuthorization = map[string]string{
	"view_permissions": "Determines the required permissions for this tenant.",
}

var docsUserAttribute = map[string]string{
	"name": "The name of the attribute.",
	"type": "The type of the attribute. Choose one of \"string\", \"number\", \"boolean\", " +
	        "\"singleselect\", \"multiselect\", \"date\".",
	"select_options": "When the attribute type is \"multiselect\". A list of options to choose from.",
	"widget_authorization": "Determines the permissions users are required to have to access this attribute " +
	                        "in the user management widget.",
}

var docsUserAttributeWidgetAuthorization = map[string]string{
	"view_permissions": "The permissions users are required to have to view this attribute in the user management widget.",
	"edit_permissions": "The permissions users are required to have to edit this attribute in the user management widget.",
}

var docsAuthentication = map[string]string{
	"otp": "A dynamically generated set of numbers, granting the user one-time access.",
	"magic_link": "An authentication method where a user receives a unique link via email to log in.",
	"enchanted_link": "An enhanced and more secure version of Magic Link, enabling users to start the authentication " +
	                  "process on one device and execute the verification on another.",
	"embedded_link": "Make the authentication experience smoother for the user by generating their initial token in a " +
	                 "way that does not require the end user to initiate the process, requiring only verification.",
	"password": "The classic username and password combination used for authentication.",
	"oauth": "Authentication using Open Authorization, which allows users to authenticate with various external " +
	         "services.",
	"sso": "Single Sign-On (SSO) authentication method that enables users to access multiple applications with " +
	       "a single set of credentials.",
	"totp": "A one-time code generated for the user using a shared secret and time.",
	"passkeys": "Device-based passwordless authentication, using fingerprint, face scan, and more.",
}

var docsEmbeddedLink = map[string]string{
	"disabled": "Setting this to `true` will disallow using this authentication method directly via " +
	            "API and SDK calls. Note that this does not affect authentication flows that are " +
	            "configured to use this authentication method.",
	"expiration_time": "How long the embedded link remains valid before it expires.",
}

var docsEnchantedLink = map[string]string{
	"disabled": "Setting this to `true` will disallow using this authentication method directly via " +
	            "API and SDK calls. Note that this does not affect authentication flows that are " +
	            "configured to use this authentication method.",
	"expiration_time": "How long the enchanted link remains valid before it expires.",
	"redirect_url": "The URL to redirect users to after they log in using the enchanted link.",
	"email_service": "Settings related to sending emails as part of the enchanted link authentication.",
}

var docsMagicLink = map[string]string{
	"disabled": "Setting this to `true` will disallow using this authentication method directly via " +
	            "API and SDK calls. Note that this does not affect authentication flows that are " +
	            "configured to use this authentication method.",
	"expiration_time": "How long the magic link remains valid before it expires.",
	"redirect_url": "The URL to redirect users to after they log in using the magic link.",
	"email_service": "Settings related to sending emails as part of the magic link authentication.",
	"text_service": "Settings related to sending SMS messages as part of the magic link authentication.",
}

var docsOAuth = map[string]string{
	"disabled": "Setting this to `true` will disallow using this authentication method directly via " +
	            "API and SDK calls. Note that this does not affect authentication flows that are " +
	            "configured to use this authentication method.",
	"system": "Custom configurations for builtin OAuth providers such as Apple, Google, GitHub, Facebook, etc.",
	"custom": "Custom OAuth providers configured for this project.",
}

var docsOAuthSystemProvider = map[string]string{
	"apple": "Apple's OAuth provider, allowing users to authenticate with their Apple Account.",
	"discord": "Discord's OAuth provider, allowing users to authenticate with their Discord account.",
	"facebook": "Facebook's OAuth provider, allowing users to authenticate with their Facebook account.",
	"github": "GitHub's OAuth provider, allowing users to authenticate with their GitHub account.",
	"gitlab": "GitLab's OAuth provider, allowing users to authenticate with their GitLab account.",
	"google": "Google's OAuth provider, allowing users to authenticate with their Google account.",
	"linkedin": "LinkedIn's OAuth provider, allowing users to authenticate with their LinkedIn account.",
	"microsoft": "Microsoft's OAuth provider, allowing users to authenticate with their Microsoft account.",
	"slack": "Slack's OAuth provider, allowing users to authenticate with their Slack account.",
}

var docsOAuthProvider = map[string]string{
	"disabled": "Setting this to `true` will disallow using this authentication method directly via " +
	            "API and SDK calls. Note that this does not affect authentication flows that are " +
	            "configured to use this authentication method.",
	"client_id": "The client ID for the OAuth provider, used to identify the application to the provider.",
	"client_secret": "The client secret for the OAuth provider, used to authenticate the application with the provider.",
	"provider_token_management": "Settings related to token management for the OAuth provider.",
	"prompts": "Custom prompts or consent screens that users may see during OAuth authentication.",
	"allowed_grant_types": "The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens " +
	                       "from the OAuth provider.",
	"scopes": "Scopes of access that the application requests from the user's account on the OAuth provider.",
	"merge_user_accounts": "Whether to merge existing user accounts with new ones created through OAuth authentication.",
	"description": "A brief description of the OAuth provider.",
	"logo": "The URL of the logo associated with the OAuth provider.",
	"issuer": "The issuer identifier for the OAuth provider.",
	"authorization_endpoint": "The URL that users are redirected to for authorization with the OAuth provider.",
	"token_endpoint": "The URL where the application requests an access token from the OAuth provider.",
	"user_info_endpoint": "The URL where the application retrieves user information from the OAuth provider.",
	"jwks_endpoint": "The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.",
	"claim_mapping": "Maps OAuth provider claims to Descope user attributes.",
}

var docsOTP = map[string]string{
	"disabled": "Setting this to `true` will disallow using this authentication method directly via " +
	            "API and SDK calls. Note that this does not affect authentication flows that are " +
	            "configured to use this authentication method.",
	"domain": "The domain to embed in OTP messages.",
	"expiration_time": "The amount of time that an OTP code will be valid for.",
	"email_service": "Settings related to sending emails with OTP codes.",
	"text_service": "Settings related to sending SMS messages with OTP codes.",
	"voice_service": "Settings related to voice calls with OTP codes.",
}

var docsPasskeys = map[string]string{
	"disabled": "Setting this to `true` will disallow using this authentication method directly via " +
	            "API and SDK calls. Note that this does not affect authentication flows that are " +
	            "configured to use this authentication method.",
	"top_level_domain": "Passkeys will be usable in the following domain and all its subdomains.",
}

var docsPassword = map[string]string{
	"disabled": "Setting this to `true` will disallow using this authentication method directly via " +
	            "API and SDK calls. Note that this does not affect authentication flows that are " +
	            "configured to use this authentication method.",
	"expiration": "Whether users are required to change their password periodically.",
	"expiration_weeks": "The number of weeks after which a user's password expires and they need to replace it.",
	"lock": "Whether the user account should be locked after a specified number of failed login attempts.",
	"lock_attempts": "The number of failed login attempts allowed before an account is locked.",
	"lowercase": "Whether passwords must contain at least one lowercase letter.",
	"min_length": "The minimum length of the password that users are required to use. The maximum length is always `64`.",
	"non_alphanumeric": "Whether passwords must contain at least one non-alphanumeric character (e.g. `!`, `@`, `#`).",
	"number": "Whether passwords must contain at least one number.",
	"reuse": "Whether to forbid password reuse when users change their password.",
	"reuse_amount": "The number of previous passwords whose hashes are kept to prevent users from " +
	                "reusing old passwords.",
	"uppercase": "Whether passwords must contain at least one uppercase letter.",
	"email_service": "Settings related to sending password reset emails as part of the password feature.",
}

var docsSSO = map[string]string{
	"disabled": "Setting this to `true` will disallow using this authentication method directly via " +
	            "API and SDK calls. Note that this does not affect authentication flows that are " +
	            "configured to use this authentication method.",
	"merge_users": "Whether to merge existing user accounts with new ones created through SSO authentication.",
}

var docsTOTP = map[string]string{
	"disabled": "Setting this to `true` will disallow using this authentication method directly via " +
	            "API and SDK calls. Note that this does not affect authentication flows that are " +
	            "configured to use this authentication method.",
}

var docsAuthorization = map[string]string{
	"roles": "A list of `Role` objects.",
	"permissions": "A list of `Permission` objects.",
}

var docsPermission = map[string]string{
	"name": "A name for the permission.",
	"description": "A description for the permission.",
}

var docsRole = map[string]string{
	"name": "A name for the role.",
	"description": "A description for the role.",
	"permissions": "A list of permissions by name to be included in the role.",
}

var docsAbuseIPDB = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"api_key": "The unique AbuseIPDB API key.",
}

var docsAmplitude = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"api_key": "The Amplitude API Key generated for the Descope service.",
	"server_url": "The server URL of the Amplitude API, when using different api or a custom domain " +
	              "in Amplitude.",
	"server_zone": "`EU` or `US`. Sets the Amplitude server zone. Set this to `EU` for Amplitude " +
	               "projects created in `EU` data center. Default is `US`.",
}

var docsAuditWebhook = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"base_url": "The base URL to fetch",
	"authentication": "Authentication Information",
	"headers": "The headers to send with the request",
	"hmac_secret": "HMAC is a method for message signing with a symmetrical key. This secret will be " +
	               "used to sign the payload, and the resulting signature will be sent in the " +
	               "`x-descope-webhook-s256` header. The receiving service should use this secret to " +
	               "verify the integrity and authenticity of the payload by checking the provided " +
	               "signature",
	"insecure": "Will ignore certificate errors raised by the client",
	"audit_filters": "Specify which events will be sent to the external audit service (including " +
	                 "tenant selection).",
}

var docsAWSS3 = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"auth_type": "The authentication type to use.",
	"access_key_id": "The unique AWS access key ID.",
	"secret_access_key": "The secret AWS access key.",
	"role_arn": "The Amazon Resource Name (ARN) of the role to assume.",
	"external_id": "The external ID to use when assuming the role.",
	"region": "The AWS S3 region, e.g. `us-east-1`.",
	"bucket": "The AWS S3 bucket. This bucket should already exist for the connector to work.",
	"audit_enabled": "Whether to enable streaming of audit events.",
	"audit_filters": "Specify which events will be sent to the external audit service (including " +
	                 "tenant selection).",
	"troubleshoot_log_enabled": "Whether to send troubleshooting events.",
}

var docsAWSTranslate = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"access_key_id": "AWS access key ID.",
	"secret_access_key": "AWS secret access key.",
	"session_token": "(Optional) A security or session token to use with these credentials. Usually " +
	                 "present for temporary credentials.",
	"region": "The AWS region to which this client will send requests. (e.g. us-east-1.)",
}

var docsClear = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"project_id": "Your CLEAR project ID.",
	"api_key": "Your CLEAR API key.",
}

var docsConnectors = map[string]string{
	"abuseipdb": "Utilize IP threat intelligence to block malicious login attempts with the " +
	             "AbuseIPDB connector.",
	"amplitude": "Track user activity and traits at any point in your user journey with the " +
	             "Amplitude connector.",
	"audit_webhook": "Send audit events to a custom webhook.",
	"aws_s3": "Stream authentication audit logs with the Amazon S3 connector.",
	"aws_translate": "Localize the language of your login and user journey screens with the Amazon Translate connector.",
	"clear": "Add sophisticated identity verification processes to your user journey with the " +
	         "CLEAR Verified connector.",
	"cybersixgill": "Utilize threat intelligence to block malicious login attempts or check leaks " +
	                "with the Cybersixgill connector.",
	"datadog": "Stream authentication audit logs with the Datadog connector.",
	"devrev_grow": "DevRev Grow is a Growth CRM that brings salespeople, product marketers, and PMs onto " +
	               "an AI-native platform to follow the journey of a visitor to a lead, to a contact, and " +
	               "then to a user - to create a champion, not a churned user.",
	"docebo": "Get user information from Docebo in your Descope user journeys with the Docebo " +
	          "connector.",
	"eight_by_eight_viber": "Send Viber messages to the user.",
	"eight_by_eight_whatsapp": "Send WhatsApp messages to the user.",
	"elephant": "Use this connector to obtain an identity trust score.",
	"external_token_http": "A generic HTTP token connector.",
	"fingerprint": "Prevent fraud by adding device intelligence with the Fingerprint connector.",
	"fingerprint_descope": "Descope Fingerprint capabilities for fraud detection and risk assessment.",
	"firebase_admin": "Firebase connector enables you to utilize Firebase's APIs to generate a Firebase user " +
	                  "token for a given Descope user.",
	"forter": "Leverage ML-based risk scores for fraud prevention with the Forter connector.",
	"generic_email_gateway": "Send emails using a generic Email gateway.",
	"generic_sms_gateway": "Send messages using a generic SMS gateway.",
	"google_cloud_translation": "Localize the language of your login and user journey screens with " +
	                            "the Google Cloud Translation connector.",
	"google_maps_places": "Get address autocompletions from Place Autocomplete Data API.",
	"hibp": "Check if passwords have been previously exposed in data breaches with the Have I " +
	        "Been Pwned connector.",
	"http": "A general purpose HTTP client",
	"hubspot": "Orchestrate customer identity information from your Descope user journey with " +
	           "the HubSpot connector.",
	"incode": "Use the Incode connection to run identity verification processes like document " +
	          "checks or facial recognition.",
	"intercom": "Orchestrate customer identity information from your Descope user journey with " +
	            "the Intercom connector.",
	"lokalise": "Localize the language of your login and user journey screens with the Lokalise " +
	            "connector.",
	"mparticle": "Track and send user event data (e.g. page views, purchases, etc.) across " +
	             "connected tools using the mParticle connector.",
	"newrelic": "Stream authentication audit logs with the New Relic connector.",
	"radar": "Get address autocompletions from Radar Autocomplete API.",
	"recaptcha": "Prevent bot attacks on your login pages with the reCAPTCHA v3 connector.",
	"recaptcha_enterprise": "Mitigate fraud using advanced risk analysis and add adaptive MFA with the reCAPTCHA Enterprise connector.",
	"rekognition": "Add image recognition capabilities for identity verification and fraud " +
	               "prevention with the Amazon Rekognition connector.",
	"salesforce": "Run SQL queries to retrieve user roles, profiles, account status, and more with " +
	              "the Salesforce connector.",
	"salesforce_marketing_cloud": "Send transactional messages with the Salesforce Marketing Cloud connector.",
	"sardine": "Evaluate customer risk using Sardine",
	"segment": "Orchestrate customer identity traits and signals from your Descope user journey " +
	           "with the Segment connector.",
	"sendgrid": "SendGrid is a cloud-based SMTP provider that allows you to send emails without having " +
	            "to maintain email servers.",
	"ses": "Amazon Simple Email Service (SES) for sending emails through AWS infrastructure.",
	"slack": "Send updates to your team on Slack.",
	"smartling": "Localize the language of your login and user journey screens with the Smartling " +
	             "connector.",
	"smtp": "Simple Mail Transfer Protocol (SMTP) server for sending emails.",
	"sns": "Amazon Simple Notification Service (SNS) for sending SMS messages through AWS.",
	"sumologic": "Stream logs and audit events with the Sumo Logic connector.",
	"supabase": "Generate external tokens for user authentication in Supabase projects.",
	"telesign": "Verify phone numbers and leverage granular risk scores for adaptive MFA with the " +
	            "Telesign Intelligence connector.",
	"traceable": "Identify and respond to fraudulent login activity with the Traceable Digital " +
	             "Fraud Prevention connector.",
	"turnstile": "Prevent bot attacks on your login pages with the Turnstile connector.",
	"twilio_core": "Twilio is a cloud-based communication provider of communication tools for making and receiving " +
	               "phone calls, sending and receiving text messages, and performing other communication functions.",
	"twilio_verify": "Twilio Verify is an OTP service that can be used via text messages, instant messaging platforms, " +
	                 "voice and e-mail. Choose this connector only if you are a Twilio Verify customer.",
}

var docsCybersixgill = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"client_id": "API Client ID issued when you create the credentials in Cybersixgill.",
	"client_secret": "Client secret issued when you create the credentials in Cybersixgill.",
}

var docsDatadog = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"api_key": "The unique Datadog organization key.",
	"site": "The Datadog site to send logs to. Default is `datadoghq.com`. European, free " +
	        "tier and other customers should set their site accordingly.",
	"audit_enabled": "Whether to enable streaming of audit events.",
	"audit_filters": "Specify which events will be sent to the external audit service (including " +
	                 "tenant selection).",
	"troubleshoot_log_enabled": "Whether to send troubleshooting events.",
}

var docsDevRevGrow = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"api_key": "Authentication to DevRev APIs requires a personal access token (PAT).",
}

var docsDocebo = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"base_url": "The Docebo api base url.",
	"client_id": "The Docebo OAuth 2.0 app client ID.",
	"client_secret": "The Docebo OAuth 2.0 app client secret.",
	"username": "The Docebo username.",
	"password": "The Docebo user's password.",
}

var docsEightByEightViber = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"sub_account_id": "The 8x8 sub-account ID is required for the Messaging API.",
	"api_key": "The 8x8 API key for authentication.",
	"country": "The country code or region where your Viber messaging service is configured.",
	"use_static_ips": "Whether the connector should send all requests from specific static IPs.",
}

var docsEightByEightWhatsapp = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"sub_account_id": "The 8x8 sub-account ID is required for the Messaging API.",
	"api_key": "The 8x8 API key for authentication.",
	"template_id": "The ID of a WhatsApp message template.",
	"country": "The country code or region where your Viber messaging service is configured.",
	"use_static_ips": "Whether the connector should send all requests from specific static IPs.",
}

var docsElephant = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"access_key": "The Elephant access key.",
}

var docsExternalTokenHTTP = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"endpoint": "The endpoint to get the token from (Using POST method). Descope will send the " +
	            "user information in the body of the request, and should return a JSON response " +
	            "with a 'token' string field.",
	"authentication": "Authentication Information",
	"headers": "The headers to send with the request",
	"hmac_secret": "HMAC is a method for message signing with a symmetrical key. This secret will be " +
	               "used to sign the base64 encoded payload, and the resulting signature will be " +
	               "sent in the `x-descope-webhook-s256` header. The receiving service should use " +
	               "this secret to verify the integrity and authenticity of the payload by checking " +
	               "the provided signature",
	"insecure": "Will ignore certificate errors raised by the client",
	"use_static_ips": "Whether the connector should send all requests from specific static IPs.",
}

var docsFingerprint = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"public_api_key": "The Fingerprint public API key.",
	"secret_api_key": "The Fingerprint secret API key.",
	"use_cloudflare_integration": "Enable to configure the relevant Cloudflare integration parameters if Cloudflare " +
	                              "integration is set in your Fingerprint account.",
	"cloudflare_script_url": "The Cloudflare integration Script URL.",
	"cloudflare_endpoint_url": "The Cloudflare integration Endpoint URL.",
}

var docsFingerprintDescope = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"custom_domain": "The custom domain to fetch",
}

var docsFirebaseAdmin = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"service_account": "The Firebase service account JSON.",
}

var docsForter = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"site_id": "The Forter site ID.",
	"secret_key": "The Forter secret key.",
	"api_version": "The Forter API version.",
	"overrides": "Override the user's IP address or email so that Forter can provide a specific " +
	             "decision or recommendation. Contact the Forter team for further details. Note: " +
	             "Overriding the user IP address or email is intended for testing purpose and " +
	             "should not be utilized in production environments.",
	"override_ip_address": "Override the user IP address.",
	"override_user_email": "Override the user email.",
}

var docsGenericEmailGateway = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"post_url": "The URL of the post email request",
	"sender": "The sender address",
	"authentication": "Authentication Information",
	"headers": "The headers to send with the request",
	"hmac_secret": "HMAC is a method for message signing with a symmetrical key. This secret will be " +
	               "used to sign the base64 encoded payload, and the resulting signature will be " +
	               "sent in the `x-descope-webhook-s256` header. The receiving service should use " +
	               "this secret to verify the integrity and authenticity of the payload by checking " +
	               "the provided signature",
	"insecure": "Will ignore certificate errors raised by the client",
	"use_static_ips": "Whether the connector should send all requests from specific static IPs.",
}

var docsGenericSMSGateway = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"post_url": "The URL of the post message request",
	"sender": "The sender number",
	"authentication": "Authentication Information",
	"headers": "The headers to send with the request",
	"hmac_secret": "HMAC is a method for message signing with a symmetrical key. This secret will be " +
	               "used to sign the base64 encoded payload, and the resulting signature will be " +
	               "sent in the `x-descope-webhook-s256` header. The receiving service should use " +
	               "this secret to verify the integrity and authenticity of the payload by checking " +
	               "the provided signature",
	"insecure": "Will ignore certificate errors raised by the client",
	"use_static_ips": "Whether the connector should send all requests from specific static IPs.",
}

var docsGoogleCloudTranslation = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"project_id": "The Google Cloud project ID where the Google Cloud Translation is managed.",
	"service_account_json": "Service Account JSON associated with the current project.",
}

var docsGoogleMapsPlaces = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"public_api_key": "The Google Maps Places public API key.",
	"address_types": "The address types to return.",
	"language": "The language in which to return results.",
	"region": "The region code, specified as a CLDR two-character region code.",
}

var docsHIBP = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
}

var docsHTTP = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"base_url": "The base URL to fetch",
	"authentication": "Authentication Information",
	"headers": "The headers to send with the request",
	"hmac_secret": "HMAC is a method for message signing with a symmetrical key. This secret will be " +
	               "used to sign the base64 encoded payload, and the resulting signature will be " +
	               "sent in the `x-descope-webhook-s256` header. The receiving service should use " +
	               "this secret to verify the integrity and authenticity of the payload by checking " +
	               "the provided signature",
	"insecure": "Will ignore certificate errors raised by the client",
	"include_headers_in_context": "The connector response context will also include the headers. The context will " +
	                              "have a \"body\" attribute and a \"headers\" attribute. See more details in the help " +
	                              "guide",
	"use_static_ips": "Whether the connector should send all requests from specific static IPs.",
}

var docsHubSpot = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"access_token": "The HubSpot private API access token generated for the Descope service.",
	"base_url": "The base URL of the HubSpot API, when using a custom domain in HubSpot, default " +
	            "value is https://api.hubapi.com .",
	"use_static_ips": "Whether the connector should send all requests from specific static IPs.",
}

var docsIncode = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"api_key": "Your InCode API key.",
	"api_url": "The base URL of the Incode API",
	"flow_id": "Your wanted InCode's flow ID.",
}

var docsIntercom = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"token": "The Intercom access token.",
	"region": "Regional Hosting - US, EU, or AU. default: US",
}

var docsLokalise = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"api_token": "Lokalise API token.",
	"project_id": "Lokalise project ID.",
	"team_id": "Lokalise team ID. If not provided, the oldest available team will be used.",
	"card_id": "(Optional) The ID of the payment card to use for translation orders. If not " +
	           "provided, the team credit will be used.",
	"translation_provider": "The translation provider to use ('gengo', 'google', 'lokalise', 'deepl'), " +
	                        "default is 'deepl'.",
}

var docsMParticle = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"api_key": "The mParticle Server to Server Key generated for the Descope service.",
	"api_secret": "The mParticle Server to Server Secret generated for the Descope service.",
	"base_url": "The base URL of the mParticle API, when using a custom domain in mParticle. " +
	            "default value is https://s2s.mparticle.com/",
	"default_environment": "The default environment of which connector send data to, either “production” or " +
	                       "“development“. default value: production. This field can be overridden per event " +
	                       "(see at flows).",
	"use_static_ips": "Whether the connector should send all requests from specific static IPs.",
}

var docsNewRelic = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"api_key": "Ingest License Key of the account you want to report data to.",
	"data_center": "The New Relic data center the account belongs to. Possible values are: `US`, " +
	               "`EU`, `FedRAMP`. Default is `US`.",
	"audit_enabled": "Whether to enable streaming of audit events.",
	"audit_filters": "Specify which events will be sent to the external audit service (including " +
	                 "tenant selection).",
	"troubleshoot_log_enabled": "Whether to send troubleshooting events.",
	"override_logs_prefix": "Enable this option to use a custom prefix for log fields.",
	"logs_prefix": "Specify a custom prefix for all log fields. The default prefix is `descope.`.",
}

var docsRadar = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"public_api_key": "The Radar publishable API key.",
	"address_types": "The address types to return.",
	"language": "The language in which to return results.",
	"region": "The region code, specified as a two-letter ISO 3166 code.",
	"limit": "The maximum number of results to return.",
}

var docsRecaptcha = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"site_key": "The site key is used to invoke reCAPTCHA service on your site or mobile " +
	            "application.",
	"secret_key": "The secret key authorizes communication between Descope backend and the " +
	              "reCAPTCHA server to verify the user's response.",
	"override_assessment": "Override the default assessment model. Note: Overriding assessment is intended " +
	                       "for automated testing and should not be utilized in production environments.",
	"assessment_score": "When configured, the Recaptcha action will return the score without assessing " +
	                    "the request. The score ranges between 0 and 1, where 1 is a human interaction " +
	                    "and 0 is a bot.",
}

var docsRecaptchaEnterprise = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"project_id": "The Google Cloud project ID where the reCAPTCHA Enterprise is managed.",
	"site_key": "The site key is used to invoke reCAPTCHA Enterprise service on your site or " +
	            "mobile application.",
	"api_key": "API key associated with the current project.",
	"override_assessment": "Override the default assessment model. Note: Overriding assessment is intended " +
	                       "for automated testing and should not be utilized in production environments.",
	"assessment_score": "When configured, the Recaptcha action will return the score without assessing " +
	                    "the request. The score ranges between 0 and 1, where 1 is a human interaction " +
	                    "and 0 is a bot.",
	"enterprise": "Enable reCAPTCHA Enterprise features for advanced bot protection, enhanced " +
	              "analytics, and enterprise-grade security.",
}

var docsRekognition = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"access_key_id": "The AWS access key ID",
	"secret_access_key": "The AWS secret access key",
	"collection_id": "The collection to store registered users in. Should match `[a-zA-Z0-9_.-]+` " +
	                 "pattern. Changing this will cause losing existing users.",
}

var docsSalesforce = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"base_url": "The Salesforce API base URL.",
	"client_id": "The consumer key of the connected app.",
	"client_secret": "The consumer secret of the connected app.",
	"version": "REST API Version.",
}

var docsSalesforceMarketingCloud = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"subdomain": "The Salesforce Marketing Cloud endpoint subdomain.",
	"client_id": "Client ID issued when you create the API integration in Installed Packages.",
	"client_secret": "Client secret issued when you create the API integration in Installed Packages.",
	"scope": "Space-separated list of data-access permissions for your connector.",
	"account_id": "Account identifier, or MID, of the target business unit.",
}

var docsSardine = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"client_id": "The Sardine Client ID.",
	"client_secret": "The Sardine Client Secret.",
	"base_url": "The base URL for the Sardine API, e.g.: https://api.sandbox.sardine.ai, " +
	            "https://api.sardine.ai, https://api.eu.sardine.ai.",
}

var docsSegment = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"write_key": "The Segment Write Key generated for the Descope service.",
	"host": "The base URL of the Segment API, when using a custom domain in Segment.",
}

var docsSendGrid = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"sender": "The sender details that should be displayed in the email message.",
	"authentication": "SendGrid API authentication configuration.",
}

var docsSendGridAuthField = map[string]string{
	"api_key": "SendGrid API key for authentication.",
}

var docsSES = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"access_key_id": "AWS Access key ID.",
	"secret": "AWS Secret Access Key.",
	"region": "AWS region to send requests to (e.g. `us-west-2`).",
	"endpoint": "An optional endpoint URL (hostname only or fully qualified URI).",
	"sender": "The sender details that should be displayed in the email message.",
}

var docsSenderField = map[string]string{
	"email": "The email address that will appear as the sender of the email.",
	"name": "The display name that will appear as the sender of the email.",
}

var docsServerField = map[string]string{
	"host": "The hostname or IP address of the SMTP server.",
	"port": "The port number to connect to on the SMTP server.",
}

var docsAuditFilterField = map[string]string{
	"key": "The field name to filter on (either 'actions' or 'tenants').",
	"operator": "The filter operation to apply ('includes' or 'excludes').",
	"values": "The list of values to match against for the filter.",
}

var docsHTTPAuthField = map[string]string{
	"bearer_token": "Bearer token for HTTP authentication.",
	"basic": "Basic authentication credentials (username and password).",
	"api_key": "API key authentication configuration.",
}

var docsHTTPAuthBasicField = map[string]string{
	"username": "Username for basic HTTP authentication.",
	"password": "Password for basic HTTP authentication.",
}

var docsHTTPAuthAPIKeyField = map[string]string{
	"key": "The API key.",
	"token": "The API secret.",
}

var docsSlack = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"token": "The OAuth token for Slack's Bot User, used to authenticate API requests.",
}

var docsSmartling = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"user_identifier": "The user identifier for the Smartling account.",
	"user_secret": "The user secret for the Smartling account.",
	"account_uid": "The account UID for the Smartling account.",
}

var docsSMTP = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"sender": "The sender details that should be displayed in the email message.",
	"server": "SMTP server connection details including hostname and port.",
	"authentication": "SMTP server authentication credentials and method.",
	"use_static_ips": "Whether the connector should send all requests from specific static IPs.",
}

var docsSMTPAuthField = map[string]string{
	"username": "Username for SMTP server authentication.",
	"password": "Password for SMTP server authentication.",
	"method": "SMTP authentication method (`plain` or `login`).",
}

var docsSNS = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"access_key_id": "AWS Access key ID.",
	"secret": "AWS Secret Access Key.",
	"region": "AWS region to send requests to (e.g. `us-west-2`).",
	"endpoint": "An optional endpoint URL (hostname only or fully qualified URI).",
	"organization_number": "An optional phone number from which the text messages are going to be sent. Make sure it " +
	                       "is registered properly in your server.",
	"sender_id": "The name of the sender from which the text message is going to be sent (see SNS documentation " +
	             "regarding acceptable IDs and supported regions/countries).",
	"entity_id": "The entity ID or principal entity (PE) ID for sending text messages to recipients in India.",
	"template_id": "The template for sending text messages to recipients in India. The template ID must be " +
	               "associated with the sender ID.",
}

var docsSumoLogic = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"http_source_url": "The URL associated with an HTTP Hosted collector",
	"audit_enabled": "Whether to enable streaming of audit events.",
	"audit_filters": "Specify which events will be sent to the external audit service (including " +
	                 "tenant selection).",
	"troubleshoot_log_enabled": "Whether to send troubleshooting events.",
}

var docsSupabase = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"signing_secret": "The signing secret for your Supabase project.",
	"expiration_time": "The duration in minutes for which the token is valid.",
}

var docsTelesign = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"customer_id": "The unique Telesign account Customer ID",
	"api_key": "The unique Telesign API key",
}

var docsTraceable = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"secret_key": "The Traceable secret key.",
	"eu_region": "EU(Europe) Region deployment of Traceable platform.",
}

var docsTurnstile = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"site_key": "The site key is used to invoke Turnstile service on your site or mobile " +
	            "application.",
	"secret_key": "The secret key authorizes communication between Descope backend and the " +
	              "Turnstile server to verify the user's response.",
}

var docsTwilioCore = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"account_sid": "Twilio Account SID from your Twilio Console.",
	"senders": "Configuration for SMS and voice message senders.",
	"authentication": "Twilio authentication credentials (either auth token or API key/secret).",
}

var docsTwilioCoreSendersField = map[string]string{
	"sms": "SMS sender configuration using either a phone number or messaging service.",
	"voice": "Voice call sender configuration.",
}

var docsTwilioCoreSendersSMSField = map[string]string{
	"phone_number": "Twilio phone number for sending SMS messages.",
	"messaging_service_sid": "Twilio Messaging Service SID for sending SMS messages.",
}

var docsTwilioCoreSendersVoiceField = map[string]string{
	"phone_number": "Twilio phone number for making voice calls.",
}

var docsTwilioAuthField = map[string]string{
	"auth_token": "Twilio Auth Token for authentication.",
	"api_key": "Twilio API Key for authentication (used with API Secret).",
	"api_secret": "Twilio API Secret for authentication (used with API Key).",
}

var docsTwilioVerify = map[string]string{
	"name": "A custom name for your connector.",
	"description": "A description of what your connector is used for.",
	"account_sid": "Twilio Account SID from your Twilio Console.",
	"service_sid": "Twilio Verify Service SID for verification services.",
	"sender": "Optional sender identifier for verification messages.",
	"authentication": "Twilio authentication credentials (either auth token or API key/secret).",
}

var docsFlow = map[string]string{
	"data": "The JSON data defining the authentication flow configuration, including metadata, screens, " +
	        "contents, and references.",
}

var docsStyles = map[string]string{
	"data": "The JSON data defining the visual styling and theme configuration used " +
	        "for authentication, widgets, etc.",
}

var docsJWTTemplate = map[string]string{
	"name": "Name of the JWT Template.",
	"description": "Description of the JWT Template.",
	"auth_schema": "The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).",
	"empty_claim_policy": "Policy for empty claims - `none`, `nil` or `delete`.",
	"conformance_issuer": "Whether to use OIDC conformance for the JWT issuer field.",
	"enforce_issuer": "Whether to enforce that the JWT issuer matches the project configuration.",
	"template": "The JSON template defining the structure and claims of the JWT token. This is expected " +
	            "to be a valid JSON object given as a `string` value.",
}

var docsJWTTemplates = map[string]string{
	"user_templates": "A list of `User` type JWT Templates.",
	"access_key_templates": "A list of `Access Key` type JWT Templates.",
}

var docsInviteSettings = map[string]string{
	"require_invitation": "Whether users must be invited before they can sign up to the project.",
	"invite_url": "Custom URL to include in the message sent to invited users.",
	"add_magiclink_token": "Whether to include a magic link token in invitation messages.",
	"send_email": "Whether to send invitation emails to users.",
	"send_text": "Whether to send invitation SMS messages to users.",
}

var docsSessionMigration = map[string]string{
	"vendor": "The name of the vendor the sessions are migrated from, in all lowercase.",
	"client_id": "The unique client ID for the vendor.",
	"domain": "The domain value if needed by the vendor.",
	"audience": "The audience value if needed by the vendor..",
	"issuer": "An issuer URL if needed by the vendor.",
	"loginid_matched_attributes": "A set of attributes from the vendor's user that should be used to match with " +
	                              "the Descope user's login ID.",
}

var docsSettings = map[string]string{
	"app_url": "The URL which your application resides on.",
	"custom_domain": "A custom CNAME that's configured to point to `cname.descope.com`. Read more about custom " +
	                 "domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).",
	"approved_domains": "The list of approved domains that are allowed for redirect and verification URLs " +
	                    "for different authentication methods.",
	"default_no_sso_apps": "Define whether a user created with no federated apps, will have access to all apps, " +
	                       "or will not have access to any app.",
	"refresh_token_rotation": "Every time the user refreshes their session token via their refresh token, the " +
	                          "refresh token itself is also updated to a new one.",
	"refresh_token_expiration": "The expiry time for the refresh token, after which the user must log in again. Use values " +
	                            "such as \"4 weeks\", \"14 days\", etc. The minimum value is \"3 minutes\".",
	"refresh_token_response_method": "Configure how refresh tokens are managed by the Descope SDKs. Must be either `response_body` " +
	                                 "or `cookies`. The default value is `response_body`.",
	"refresh_token_cookie_policy": "Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy " +
	                               "[here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).",
	"refresh_token_cookie_domain": "The domain name for refresh token cookies. To read more about custom domain and " +
	                               "cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).",
	"session_token_expiration": "The expiry time of the session token, used for accessing the application's resources. The value " +
	                            "needs to be at least 3 minutes and can't be longer than the refresh token expiration.",
	"session_token_response_method": "Configure how sessions tokens are managed by the Descope SDKs. Must be either `response_body` " +
	                                 "or `cookies`. The default value is `response_body`.",
	"session_token_cookie_policy": "Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy " +
	                               "[here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).",
	"session_token_cookie_domain": "The domain name for session token cookies. To read more about custom domain and " +
	                               "cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).",
	"step_up_token_expiration": "The expiry time for the step up token, after which it will not be valid and the user will " +
	                            "automatically go back to the session token.",
	"trusted_device_token_expiration": "The expiry time for the trusted device token. The minimum value is \"3 minutes\".",
	"access_key_session_token_expiration": "The expiry time for access key session tokens. Use values such as \"10 minutes\", \"4 hours\", etc. The " +
	                                       "value needs to be at least 3 minutes and can't be longer than 4 weeks.",
	"enable_inactivity": "Use `True` to enable session inactivity. To read more about session inactivity " +
	                     "click [here](https://docs.descope.com/project-settings#session-inactivity).",
	"inactivity_time": "The session inactivity time. Use values such as \"15 minutes\", \"1 hour\", etc. The minimum " +
	                   "value is \"10 minutes\".",
	"test_users_loginid_regexp": "Define a regular expression so that whenever a user is created with a matching login ID it will " +
	                             "automatically be marked as a test user.",
	"test_users_verifier_regexp": "The pattern of the verifiers that will be used for testing.",
	"test_users_static_otp": "A 6 digit static OTP code for use with test users.",
	"user_jwt_template": "Name of the user JWT Template.",
	"access_key_jwt_template": "Name of the access key JWT Template.",
	"session_migration": "Configure seamless migration of existing user sessions from another vendor to Descope.",
}

var docsEmailService = map[string]string{
	"connector": "The name of the email connector to use for sending emails.",
	"templates": "A list of email templates for different authentication flows.",
}

var docsEmailTemplate = map[string]string{
	"active": "Whether this email template is currently active and in use.",
	"name": "Unique name for this email template.",
	"subject": "Subject line of the email message.",
	"html_body": "HTML content of the email message body, required if `use_plain_text_body` isn't set.",
	"plain_text_body": "Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.",
	"use_plain_text_body": "Whether to use the plain text body instead of HTML for the email.",
}

var docsTextService = map[string]string{
	"connector": "The name of the SMS/text connector to use for sending text messages.",
	"templates": "A list of text message templates for different authentication flows.",
}

var docsTextTemplate = map[string]string{
	"active": "Whether this text template is currently active and in use.",
	"name": "Unique name for this text template.",
	"body": "The content of the text message.",
}

var docsVoiceService = map[string]string{
	"connector": "The name of the voice connector to use for making voice calls.",
	"templates": "A list of voice message templates for different purposes.",
}

var docsVoiceTemplate = map[string]string{
	"active": "Whether this voice template is currently active and in use.",
	"name": "Unique name for this voice template.",
	"body": "The content of the voice message that will be spoken.",
}
